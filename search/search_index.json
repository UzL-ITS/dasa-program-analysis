{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"DASA - Differentiable Abstract Symbolic Analyzer","text":"<p>DASA is an optimization-driven engine for symbolic program analysis. Instead of using traditional constraint solvers, DASA converts Java programs into differentiable computational graphs and uses gradient-based optimization to discover inputs that lead to specific execution paths or target conditions.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Gradient-Based Analysis: Uses PyTorch and Adam optimizer to find test inputs</li> <li>Automatic Input Discovery: Finds inputs that trigger assertion violations, exceptions, and specific code paths</li> <li>Differentiable Execution: Models control flow and computations as differentiable operations</li> <li>Type-Aware Optimization: Specialized handling for integers, floats, booleans, chars, and strings</li> </ul>"},{"location":"#how-it-works","title":"How It Works","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Java Source \u2502\u2500\u2500\u2500\u25b6\u2502   GraalVM   \u2502\u2500\u2500\u2500\u25b6\u2502   Graph     \u2502\u2500\u2500\u2500\u25b6\u2502  Gradient   \u2502\n\u2502   Program   \u2502    \u2502  Compiler   \u2502    \u2502  Builder    \u2502    \u2502 Optimization\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2502                  \u2502                  \u2502\n                          \u25bc                  \u25bc                  \u25bc\n                   Compiler IR         Python Graph      Found Inputs\n                   (BGV format)        (PyTorch)         (Violations)\n</code></pre> <ol> <li>Compile: GraalVM compiles Java code and exports compiler intermediate representation</li> <li>Build Graph: DASA converts the IR into a differentiable PyTorch computation graph</li> <li>Optimize: Gradient descent finds input values that maximize reachability to target nodes</li> <li>Validate: Generated inputs are executed against the original Java program</li> </ol>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>// Main.java - Find input that triggers assertion\nimport org.sosy_lab.sv_benchmarks.Verifier;\n\nclass Main {\n    public static void main(String[] args) {\n        int x = Verifier.nondetInt();\n        if (x &gt;= 100) {\n            assert false : \"Found large value!\";\n        }\n    }\n}\n</code></pre> <p>DASA will automatically discover that <code>x = 100</code> (or any value &gt;= 100) triggers the assertion.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation - Set up DASA on your system</li> <li>Quick Start - Run your first analysis in 5 minutes</li> <li>Usage Examples - Detailed examples and use cases</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - University of L\u00fcbeck, Institute for IT Security</p>"},{"location":"api/","title":"API Reference","text":"<p>This page documents the main Python API for using DASA programmatically.</p>"},{"location":"api/#testmain","title":"test.main()","text":"<p>The primary entry point for running DASA analysis.</p> <pre><code>def main(\n    target_file: str,\n    start_nodes: list | None,\n    end_nodes: list | None,\n    auto_detect_start_end: bool = False,\n    test_dir: str | None = None,\n    test_class: str | None = None,\n    use_sv_helpers: bool = True,\n    return_successfull_output: bool = False,\n    num_iterations: int = 1,\n    verbose: bool = False\n) -&gt; int | tuple[int, str]\n</code></pre>"},{"location":"api/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>target_file</code> <code>str</code> required Path to the JSON graph file (e.g., <code>Main.main.json</code>) <code>start_nodes</code> <code>list[input_node_tuple]</code> <code>None</code> List of input source nodes. Set to <code>None</code> with <code>auto_detect_start_end=True</code> <code>end_nodes</code> <code>list[int]</code> <code>None</code> List of target node IDs. Set to <code>None</code> with <code>auto_detect_start_end=True</code> <code>auto_detect_start_end</code> <code>bool</code> <code>False</code> Automatically detect input and target nodes from <code>Verifier.*</code> calls <code>test_dir</code> <code>str</code> <code>None</code> Directory containing compiled <code>.class</code> files for validation <code>test_class</code> <code>str</code> <code>None</code> Name of the main class to execute <code>use_sv_helpers</code> <code>bool</code> <code>True</code> Include <code>svHelpers/evaluation/</code> in the Java classpath <code>return_successfull_output</code> <code>bool</code> <code>False</code> Return stdout along with result code on success <code>num_iterations</code> <code>int</code> <code>1</code> Number of optimization attempts per target node <code>verbose</code> <code>bool</code> <code>False</code> Print detailed iteration progress"},{"location":"api/#return-values","title":"Return Values","text":"Code Constant Description 0 <code>STATE_DEFAULT</code> Default/unset state 1 <code>STATE_NO_START_NODES_FOUND</code> No <code>Verifier.nondet*()</code> calls found 2 <code>STATE_NO_END_NODES_FOUND</code> No assertion/exception targets found 3 <code>STATE_CORRECT</code> Successfully found violation 4 <code>STATE_INCORRECT</code> Ran but no violation triggered 5 <code>STATE_ERROR</code> Error during analysis <p>If <code>return_successfull_output=True</code> and a violation is found, returns <code>(STATE_CORRECT, stdout_string)</code>.</p>"},{"location":"api/#example","title":"Example","text":"<pre><code>import test\n\nresult = test.main(\n    target_file='Main.main.json',\n    start_nodes=None,\n    end_nodes=None,\n    auto_detect_start_end=True,\n    test_dir='SUTs/MyProgram/',\n    test_class='Main',\n    num_iterations=10,\n    verbose=True\n)\n\nif result == test.STATE_CORRECT:\n    print(\"Found violation!\")\n</code></pre>"},{"location":"api/#testrun_optimization","title":"test.run_optimization()","text":"<p>Low-level optimization function. Called internally by <code>main()</code>.</p> <pre><code>def run_optimization(\n    graph: dict,\n    input_ids: list[int],\n    output_id: int,\n    graph_builder: GraphBuilder,\n    verbose: bool = False,\n    I_all: list | None = None\n) -&gt; dict\n</code></pre>"},{"location":"api/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>graph</code> <code>dict[int, BaseNode]</code> Constructed computation graph <code>input_ids</code> <code>list[int]</code> Node IDs for input sources <code>output_id</code> <code>int</code> Target node ID <code>graph_builder</code> <code>GraphBuilder</code> Graph builder instance <code>verbose</code> <code>bool</code> Print iteration progress <code>I_all</code> <code>list</code> Initial input values (auto-generated if <code>None</code>)"},{"location":"api/#returns","title":"Returns","text":"<pre><code>{\n    \"iteration\": int,      # Final iteration count\n    \"loss\": float,         # Final loss value\n    \"values\": list,        # Discovered input values (None for unused)\n    \"all_values\": list     # All input values including unused\n}\n</code></pre>"},{"location":"api/#graalwrappergraphbuilder","title":"GraalWrapper.GraphBuilder","text":"<p>Loads and constructs computation graphs from GraalVM JSON output.</p> <pre><code>class GraphBuilder:\n    def __init__(\n        self,\n        graph_json_file: str,\n        work_dir: str | None = None,\n        rec_list: list | None = None\n    )\n</code></pre>"},{"location":"api/#methods","title":"Methods","text":""},{"location":"api/#get_graph","title":"get_graph()","text":"<pre><code>def get_graph(\n    self,\n    start_node: int,\n    end_node: int,\n    reset: bool = False,\n    verbose: bool = False\n) -&gt; dict[int, BaseNode]\n</code></pre> <p>Returns the constructed graph as a dictionary mapping node IDs to node objects.</p>"},{"location":"api/#get_start_end_constant_nodes","title":"get_start_end_constant_nodes()","text":"<pre><code>def get_start_end_constant_nodes(self) -&gt; tuple[list, list, dict]\n</code></pre> <p>Auto-detects:</p> <ul> <li><code>start_nodes</code>: Nodes from <code>Verifier.nondet*()</code> calls</li> <li><code>end_nodes</code>: Nodes for assertions/exceptions</li> <li><code>constant_nodes</code>: Constant values in the program</li> </ul>"},{"location":"api/#inputnodetypes","title":"InputNodeTypes","text":"<p>Type conversion utilities for input nodes.</p>"},{"location":"api/#input_node_tuple","title":"input_node_tuple","text":"<pre><code>from GraalWrapper.InputNodeTypes import input_node_tuple\n\nnode = input_node_tuple(node_id=33, func=TYPE_CONV_INT)\n</code></pre>"},{"location":"api/#string_input_node_tuple","title":"string_input_node_tuple","text":"<pre><code>from GraalWrapper.InputNodeTypes import string_input_node_tuple\n\nnode = string_input_node_tuple(\n    node_id=45,\n    func=TYPE_CONV_STRING,\n    string_length=20\n)\n</code></pre>"},{"location":"api/#type-converters","title":"Type Converters","text":"Constant Java Type Description <code>TYPE_CONV_INT</code> <code>int</code> 32-bit signed integer <code>TYPE_CONV_LONG</code> <code>long</code> 64-bit signed integer <code>TYPE_CONV_FLOAT</code> <code>float</code> 32-bit float <code>TYPE_CONV_BOOL</code> <code>boolean</code> Boolean <code>TYPE_CONV_CHAR</code> <code>char</code> 16-bit Unicode character <code>TYPE_CONV_BYTE</code> <code>byte</code> 8-bit signed integer <code>TYPE_CONV_SHORT</code> <code>short</code> 16-bit signed integer <code>TYPE_CONV_STRING</code> <code>String</code> String (use <code>string_input_node_tuple</code>) <code>TYPE_CONV_DEFAULT</code> varies Default conversion"},{"location":"api/#nodesbasenode","title":"nodes.BaseNode","text":"<p>Base class for all computation nodes.</p> <pre><code>class BaseNode:\n    def __init__(self, node: dict):\n        self.node = node                    # Original JSON node data\n        self.controlFlowMultiplicative = torch.tensor(1.0)\n        self.node_penalty = 0               # Additional loss term\n        self.children = {}                  # Child nodes\n        self.inputs = {}                    # Input values\n        self.output = None                  # Computed output\n        self.executed = False               # Has been executed\n</code></pre>"},{"location":"api/#key-methods","title":"Key Methods","text":"Method Description <code>exec()</code> Perform node computation <code>add_child(child, edge)</code> Register a child node <code>add_parent(parent, edge)</code> Register a parent node <code>add_input(value, edge, flow)</code> Receive input value <code>set_output(value)</code> Propagate output to children <code>reset_inputs()</code> Reset for new iteration"},{"location":"api/#nodestypesstring","title":"nodes.types.String","text":"<p>Differentiable string type using Gumbel-Softmax.</p> <pre><code>from nodes.types import String\n\ns = String(\n    length=10,\n    initialization_bias='uniform',\n    initialization_words=set()\n)\n\n# Get optimizable parameters for Adam\nparams = s.get_optimize_parameter()\n\n# Convert to actual string\ntext = s.to_string()\n</code></pre>"},{"location":"api/#class-methods","title":"Class Methods","text":"<pre><code>String.set_temperature(0.5)  # Set Gumbel-Softmax temperature\n</code></pre>"},{"location":"api/#nodescustomsigmoid","title":"nodes.custom.Sigmoid","text":"<p>Annealing sigmoid for differentiable control flow.</p> <pre><code>from nodes.custom import Sigmoid\n\n# Set annealing constant (0.001 to 1.0)\nSigmoid.set_annealing_constant(0.5)\n</code></pre> <p>Lower values = softer decisions (more gradient flow) Higher values = sharper decisions (more discrete)</p>"},{"location":"architecture/","title":"Architecture","text":"<p>This page explains how DASA works internally.</p>"},{"location":"architecture/#system-overview","title":"System Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         DASA Pipeline                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502   Java      \u2502     \u2502   GraalVM   \u2502     \u2502   seafoam           \u2502   \u2502\n\u2502  \u2502   Source    \u2502\u2500\u2500\u2500\u2500\u25b6\u2502   native-   \u2502\u2500\u2500\u2500\u2500\u25b6\u2502   bgv2json          \u2502   \u2502\n\u2502  \u2502   (.java)   \u2502     \u2502   image     \u2502     \u2502                     \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                             \u2502                      \u2502               \u2502\n\u2502                             \u25bc                      \u25bc               \u2502\n\u2502                      graal_dumps/           Method.main.json       \u2502\n\u2502                      (BGV files)            (Graph JSON)           \u2502\n\u2502                                                    \u2502               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502                  Python Analysis                \u2502           \u2502   \u2502\n\u2502  \u2502                                                 \u25bc           \u2502   \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502   \u2502\n\u2502  \u2502  \u2502 GraphBuilder\u2502\u2500\u2500\u2500\u2500\u25b6\u2502  PyTorch    \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 run_          \u2502  \u2502   \u2502\n\u2502  \u2502  \u2502 (load JSON) \u2502     \u2502  Graph      \u2502     \u2502 optimization  \u2502  \u2502   \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502   \u2502\n\u2502  \u2502                                                 \u2502           \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                                    \u25bc               \u2502\n\u2502                                          Found Input Values        \u2502\n\u2502                                                    \u2502               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502                  Validation                     \u25bc           \u2502   \u2502\n\u2502  \u2502            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502   \u2502\n\u2502  \u2502            \u2502  java -ea Main &lt; generated_inputs       \u2502      \u2502   \u2502\n\u2502  \u2502            \u2502  \u2192 AssertionError (if successful)       \u2502      \u2502   \u2502\n\u2502  \u2502            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#stage-1-graph-extraction","title":"Stage 1: Graph Extraction","text":""},{"location":"architecture/#graalvm-compilation","title":"GraalVM Compilation","text":"<p>GraalVM's <code>native-image</code> compiles Java to native code while dumping compiler intermediate representation:</p> <pre><code>native-image -H:Dump=:1 -H:MaximumInliningSize=0 Main\n</code></pre> <p>This creates BGV (Binary Graph Visualization) files in <code>graal_dumps/</code>.</p>"},{"location":"architecture/#json-conversion","title":"JSON Conversion","text":"<p>The <code>seafoam</code> tool converts BGV to readable JSON:</p> <pre><code>bgv2json \"graal_dumps/.../[Main.main].bgv\" &gt; Main.main.json\n</code></pre>"},{"location":"architecture/#json-structure","title":"JSON Structure","text":"<pre><code>{\n  \"nodes\": [\n    {\n      \"id\": 33,\n      \"props\": {\n        \"node_class\": {\"node_class\": \"jdk.graal.compiler.nodes.InvokeNode\"},\n        \"targetMethod\": \"Verifier.nondetInt\",\n        ...\n      }\n    },\n    ...\n  ],\n  \"edges\": [\n    {\"from\": 33, \"to\": 45, \"props\": {\"name\": \"next\", \"type\": \"Control\"}},\n    ...\n  ]\n}\n</code></pre>"},{"location":"architecture/#stage-2-graph-building","title":"Stage 2: Graph Building","text":""},{"location":"architecture/#graphbuilder-class","title":"GraphBuilder Class","text":"<p><code>GraalWrapper/GraphBuilder.py</code> converts JSON to Python objects:</p> <pre><code>graph_builder = GraphBuilder('Main.main.json')\ngraph = graph_builder.get_graph(start_node=0, end_node=target)\n</code></pre>"},{"location":"architecture/#node-type-mapping","title":"Node Type Mapping","text":"<p>GraalVM node classes are mapped to Python classes:</p> GraalVM Node Python Class Purpose <code>ConstantNode</code> <code>nodes.ConstantNode</code> Literal values <code>InvokeNode</code> <code>nodes.InvokeNode</code> Method calls <code>IfNode</code> <code>nodes.IfNode</code> Conditional branches <code>AddNode</code> <code>nodes.calc.AddNode</code> Integer addition <code>IntegerLessThanNode</code> <code>nodes.calc.IntegerLessThanNode</code> Comparison <code>ThrowBytecodeExceptionNode</code> Target node Assertion/exception"},{"location":"architecture/#backward-slicing","title":"Backward Slicing","text":"<p>Only nodes reachable from the target are included:</p> <pre><code>def do_backward_slicing(self, graph, end_node):\n    # BFS from end_node to find all contributing nodes\n    visited = set()\n    queue = [end_node]\n    while queue:\n        node = queue.pop(0)\n        visited.add(node)\n        for edge in graph['edges']:\n            if edge['to'] == node and edge['from'] not in visited:\n                queue.append(edge['from'])\n    return visited\n</code></pre>"},{"location":"architecture/#stage-3-optimization","title":"Stage 3: Optimization","text":""},{"location":"architecture/#control-flow-modeling","title":"Control Flow Modeling","text":"<p>Each node has a <code>controlFlowMultiplicative</code> score (0.0 to 1.0) indicating path reachability:</p> <pre><code>class BaseNode:\n    def __init__(self, node):\n        self.controlFlowMultiplicative = torch.tensor(1.0)\n</code></pre> <p>At merge points, the minimum is taken:</p> <pre><code>self.controlFlowMultiplicative = torch.min(\n    incoming_flow,\n    self.controlFlowMultiplicative\n)\n</code></pre>"},{"location":"architecture/#differentiable-conditionals","title":"Differentiable Conditionals","text":"<p><code>IfNode</code> uses a sigmoid to make branching differentiable:</p> <pre><code>class IfNode(BaseNode):\n    def exec(self):\n        condition = self.inputs['condition']\n        # Sigmoid makes this differentiable\n        prob_true = torch.sigmoid(condition * annealing_factor)\n        prob_false = 1 - prob_true\n\n        self.children['trueSuccessor'].controlFlowMultiplicative *= prob_true\n        self.children['falseSuccessor'].controlFlowMultiplicative *= prob_false\n</code></pre>"},{"location":"architecture/#loss-function","title":"Loss Function","text":"<p>The loss maximizes reachability to the target:</p> <pre><code>loss = -graph[target_node].controlFlowMultiplicative\n\n# Add penalties for complex operations\nfor node in graph.values():\n    if node.node_penalty:\n        loss += node.node_penalty\n</code></pre>"},{"location":"architecture/#adam-optimizer","title":"Adam Optimizer","text":"<pre><code>optimizer = optim.Adam(input_parameters, lr=0.1)\n\nfor i in range(num_iterations):\n    optimizer.zero_grad()\n\n    # Forward pass: execute graph\n    execute_graph(graph, inputs)\n\n    # Compute loss\n    loss = -graph[target].controlFlowMultiplicative\n\n    # Backward pass: compute gradients\n    loss.backward()\n\n    # Update inputs\n    optimizer.step()\n</code></pre>"},{"location":"architecture/#stage-4-validation","title":"Stage 4: Validation","text":"<p>Generated inputs are fed to the actual Java program:</p> <pre><code>inputs = \"INPUT_000 42\\nINPUT_001 17\"\nresult = subprocess.run(\n    [\"java\", \"-ea\", \"Main\"],\n    input=inputs.encode(),\n    capture_output=True\n)\n\nif \"AssertionError\" in result.stderr.decode():\n    return STATE_CORRECT\n</code></pre>"},{"location":"architecture/#key-design-decisions","title":"Key Design Decisions","text":""},{"location":"architecture/#why-graalvm","title":"Why GraalVM?","text":"<ul> <li>Produces detailed compiler IR with semantic information</li> <li>BGV format captures control flow, data flow, and type information</li> <li><code>native-image</code> enables ahead-of-time analysis</li> </ul>"},{"location":"architecture/#why-gradient-descent","title":"Why Gradient Descent?","text":"<ul> <li>Scales to complex constraint combinations</li> <li>Handles non-linear relationships naturally</li> <li>Annealing allows exploration then exploitation</li> </ul>"},{"location":"architecture/#why-differentiable-execution","title":"Why Differentiable Execution?","text":"<ul> <li>Gradients guide search toward targets</li> <li>Soft control flow enables gradient flow through branches</li> <li>Temperature annealing sharpens decisions over time</li> </ul>"},{"location":"architecture/#file-structure","title":"File Structure","text":"<pre><code>dasa-program-analysis/\n\u251c\u2500\u2500 test.py                 # Main optimization loop\n\u251c\u2500\u2500 run_sv-comp.py          # SV-COMP competition entry\n\u251c\u2500\u2500 GraalWrapper/\n\u2502   \u251c\u2500\u2500 GraphBuilder.py     # JSON \u2192 Python graph\n\u2502   \u251c\u2500\u2500 MethodRegister.py   # Inlined method tracking\n\u2502   \u2514\u2500\u2500 InputNodeTypes.py   # Type conversion utilities\n\u251c\u2500\u2500 nodes/\n\u2502   \u251c\u2500\u2500 BaseNode.py         # Base class\n\u2502   \u251c\u2500\u2500 IfNode.py           # Conditional branching\n\u2502   \u251c\u2500\u2500 calc/               # Arithmetic operations\n\u2502   \u251c\u2500\u2500 java/               # Java operations\n\u2502   \u251c\u2500\u2500 types/              # Complex types\n\u2502   \u2514\u2500\u2500 custom/             # Custom operations\n\u251c\u2500\u2500 scripts/\n\u2502   \u2514\u2500\u2500 entrypoint.sh       # Docker entry point\n\u2514\u2500\u2500 Dockerfile              # GraalVM container\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>DASA's behavior can be tuned through various parameters in the optimization process.</p>"},{"location":"configuration/#optimization-parameters","title":"Optimization Parameters","text":"<p>These parameters are set in <code>test.py:run_optimization()</code>:</p>"},{"location":"configuration/#iterations","title":"Iterations","text":"<pre><code>num_iterations = 2000  # Maximum optimization steps\n</code></pre> <p>More iterations allow finding harder-to-reach targets but increase runtime.</p>"},{"location":"configuration/#learning-rate","title":"Learning Rate","text":"<pre><code>initial_lr = 0.1  # Adam optimizer learning rate\n</code></pre> <ul> <li>Higher values: Faster convergence but may overshoot</li> <li>Lower values: More stable but slower</li> </ul>"},{"location":"configuration/#sigmoid-annealing","title":"Sigmoid Annealing","text":"<pre><code>sigmoid_annealing_start = 0.001\nsigmoid_annealing_end = 1.0\n</code></pre> <p>Controls how \"soft\" control flow decisions are during optimization:</p> <ul> <li>Early iterations: Soft decisions allow gradient flow through all branches</li> <li>Later iterations: Sharp decisions commit to specific paths</li> </ul>"},{"location":"configuration/#temperature-annealing-strings","title":"Temperature Annealing (Strings)","text":"<pre><code>temp_start = 2.0   # High: exploratory sampling\ntemp_end = 0.1     # Low: sharp character selection\n</code></pre> <p>For Gumbel-Softmax string generation:</p> <ul> <li>High temperature: Smooth probability distribution</li> <li>Low temperature: Near-deterministic character selection</li> </ul>"},{"location":"configuration/#early-stopping","title":"Early Stopping","text":"<pre><code>min_loss_delta = 1e-12  # Stop if loss changes less than this\n</code></pre> <p>Optimization stops early when loss plateaus.</p>"},{"location":"configuration/#docker-configuration","title":"Docker Configuration","text":""},{"location":"configuration/#environment-variables","title":"Environment Variables","text":"Variable Default Description <code>TARGET</code> <code>Main</code> Main class name to analyze"},{"location":"configuration/#volume-mounts","title":"Volume Mounts","text":"<pre><code>docker run --rm \\\n  -v \"/path/to/java/files:/SUT\" \\      # Java source files\n  -v \"/path/to/verifier:/svHelpers\" \\  # Verifier.java location\n  dasa-graph-extractor\n</code></pre>"},{"location":"configuration/#test-execution-parameters","title":"Test Execution Parameters","text":"<p>When calling <code>test.main()</code>:</p> Parameter Type Description <code>target_file</code> <code>str</code> Path to JSON graph file <code>start_nodes</code> <code>list</code> Input nodes (or <code>None</code> for auto) <code>end_nodes</code> <code>list</code> Target nodes (or <code>None</code> for auto) <code>auto_detect_start_end</code> <code>bool</code> Auto-detect input/target nodes <code>test_dir</code> <code>str</code> Directory with .class files <code>test_class</code> <code>str</code> Main class name <code>use_sv_helpers</code> <code>bool</code> Include svHelpers in classpath <code>return_successfull_output</code> <code>bool</code> Return stdout on success <code>num_iterations</code> <code>int</code> Optimization attempts per target <code>verbose</code> <code>bool</code> Print iteration progress"},{"location":"configuration/#initial-value-strategies","title":"Initial Value Strategies","text":"<p>DASA uses smart initialization for different types:</p>"},{"location":"configuration/#integers","title":"Integers","text":"<pre><code># 70% chance: 2-14 bit values (common range)\n# 30% chance: 15-31 bit values (edge cases)\n# 5% chance: special values (0, -1, 1, MIN, MAX)\n</code></pre>"},{"location":"configuration/#floats","title":"Floats","text":"<p>Similar to integers but includes floating-point ranges.</p>"},{"location":"configuration/#booleans","title":"Booleans","text":"<pre><code># 50% true, 50% false\n</code></pre>"},{"location":"configuration/#characters","title":"Characters","text":"<pre><code># 90% chance: printable ASCII (32-125)\n# 10% chance: full Unicode range\n</code></pre>"},{"location":"configuration/#strings","title":"Strings","text":"<pre><code># Default length: 10 characters\n# Initialization: uniform distribution or biased toward constants\n</code></pre>"},{"location":"configuration/#timeout-configuration","title":"Timeout Configuration","text":"<p>In <code>test.py</code>:</p> <pre><code># 10-minute global timeout per analysis\nif datetime.now() - start_time &gt;= timedelta(minutes=10):\n    break\n</code></pre>"},{"location":"configuration/#graalvm-options","title":"GraalVM Options","text":"<p>In <code>scripts/entrypoint.sh</code>:</p> <pre><code>native-image -ea \\\n  -H:Dump=:1 \\                  # Dump compiler graphs\n  -H:MaximumInliningSize=0 \\    # Disable inlining\n  -H:+UnlockExperimentalVMOptions \\\n  $TARGET\n</code></pre> <p>If graph generation fails, it retries with <code>-O0</code> (no optimization).</p>"},{"location":"configuration/#customizing-node-behavior","title":"Customizing Node Behavior","text":"<p>To modify how specific nodes behave, edit files in <code>nodes/</code>:</p> <pre><code>nodes/\n\u251c\u2500\u2500 calc/           # Math operations\n\u251c\u2500\u2500 java/           # Java-specific operations\n\u251c\u2500\u2500 types/          # Complex types (String, Array)\n\u251c\u2500\u2500 custom/         # Custom operations (Sigmoid)\n\u2514\u2500\u2500 BaseNode.py     # Base class for all nodes\n</code></pre> <p>Each node can define:</p> <ul> <li><code>exec()</code>: Computation logic</li> <li><code>node_penalty</code>: Additional loss term</li> <li><code>controlFlowMultiplicative</code>: Path reachability score</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to DASA!</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the repository</li> <li>Clone your fork:    <pre><code>git clone https://github.com/YOUR_USERNAME/dasa-program-analysis.git\n</code></pre></li> <li>Set up the development environment (see Installation)</li> </ol>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run smoke tests\n./smoketest.sh\n\n# Or manually:\nsource venv/bin/activate\npython3 -c \"\nimport test\nresult = test.main('Main.main.json', None, None, True, 'SUTs/Smoketest1/', 'Main', 3)\nassert result == 3, 'Smoketest1 failed'\nprint('All tests passed!')\n\"\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow PEP 8 for Python code</li> <li>Use meaningful variable names</li> <li>Add docstrings to new functions and classes</li> <li>Keep functions focused and small</li> </ul>"},{"location":"contributing/#adding-new-node-types","title":"Adding New Node Types","text":"<ol> <li>Identify the GraalVM node class name from the JSON graph</li> <li>Create a new Python class in <code>nodes/</code> (see Node Types)</li> <li>Register the mapping in <code>GraalWrapper/GraphBuilder.py</code></li> <li>Add tests for the new node type</li> </ol>"},{"location":"contributing/#testing-your-changes","title":"Testing Your Changes","text":"<p>Create a test case in <code>SUTs/</code>:</p> <pre><code>mkdir SUTs/MyTest\n</code></pre> <p>Create <code>SUTs/MyTest/Main.java</code> that exercises your changes.</p> <p>Run the full pipeline:</p> <pre><code># Generate graph\ndocker run --rm \\\n  -v \"$(pwd)/SUTs/MyTest:/SUT\" \\\n  -v \"$(pwd)/svHelpers/evaluation:/svHelpers\" \\\n  dasa-graph-extractor\n\n# Compile and test\njavac -cp svHelpers/evaluation SUTs/MyTest/Main.java -d SUTs/MyTest/\npython3 -c \"\nimport test\nresult = test.main('Main.main.json', None, None, True, 'SUTs/MyTest/', 'Main', 5)\nprint(f'Result: {result}')\n\"\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li> <p>Create a feature branch:    <pre><code>git checkout -b feature/my-new-feature\n</code></pre></p> </li> <li> <p>Make your changes with clear commit messages</p> </li> <li> <p>Ensure all tests pass</p> </li> <li> <p>Push to your fork:    <pre><code>git push origin feature/my-new-feature\n</code></pre></p> </li> <li> <p>Open a Pull Request with:</p> </li> <li>Clear description of the change</li> <li>Any relevant issue numbers</li> <li>Test results</li> </ol>"},{"location":"contributing/#areas-for-contribution","title":"Areas for Contribution","text":""},{"location":"contributing/#high-priority","title":"High Priority","text":"<ul> <li>New node types: Many GraalVM node types fall back to <code>FallbackNode</code></li> <li>String operations: Improve differentiable string handling</li> <li>Performance: Optimize the optimization loop</li> <li>Documentation: Improve examples and explanations</li> </ul>"},{"location":"contributing/#medium-priority","title":"Medium Priority","text":"<ul> <li>Error handling: Better error messages and recovery</li> <li>Logging: Add structured logging</li> <li>Configuration: More tunable parameters</li> <li>Visualization: Graph visualization tools</li> </ul>"},{"location":"contributing/#good-first-issues","title":"Good First Issues","text":"<ul> <li>Add missing type converters in <code>InputNodeTypes.py</code></li> <li>Improve error messages when graph loading fails</li> <li>Add more example programs in <code>SUTs/</code></li> <li>Fix typos in documentation</li> </ul>"},{"location":"contributing/#code-structure","title":"Code Structure","text":"<pre><code>dasa-program-analysis/\n\u251c\u2500\u2500 test.py                 # Main entry point - optimization loop\n\u251c\u2500\u2500 run_sv-comp.py          # SV-COMP competition wrapper\n\u251c\u2500\u2500 GraalWrapper/\n\u2502   \u251c\u2500\u2500 GraphBuilder.py     # Graph construction (most complex)\n\u2502   \u251c\u2500\u2500 MethodRegister.py   # Method inlining tracking\n\u2502   \u2514\u2500\u2500 InputNodeTypes.py   # Type conversions\n\u251c\u2500\u2500 nodes/\n\u2502   \u251c\u2500\u2500 BaseNode.py         # Base class for all nodes\n\u2502   \u251c\u2500\u2500 calc/               # Arithmetic and comparison\n\u2502   \u251c\u2500\u2500 java/               # Java-specific operations\n\u2502   \u251c\u2500\u2500 types/              # Complex types (String, Array)\n\u2502   \u251c\u2500\u2500 virtual/            # Object allocation\n\u2502   \u2514\u2500\u2500 custom/             # Custom operations\n\u251c\u2500\u2500 scripts/\n\u2502   \u2514\u2500\u2500 entrypoint.sh       # Docker entry point\n\u251c\u2500\u2500 SUTs/                   # Test programs\n\u251c\u2500\u2500 svHelpers/              # SV-COMP Verifier class\n\u2514\u2500\u2500 docs/                   # Documentation (you are here)\n</code></pre>"},{"location":"contributing/#questions","title":"Questions?","text":"<ul> <li>Open an issue for bugs or feature requests</li> <li>Check existing issues before creating new ones</li> <li>Be respectful and constructive in discussions</li> </ul>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"installation/","title":"Installation","text":"<p>DASA uses a two-stage pipeline: Docker for graph extraction (requires GraalVM) and local Python for optimization.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"Component Version Purpose Docker 20.0+ GraalVM graph extraction Python 3.9+ Optimization and analysis Java 17+ Test execution"},{"location":"installation/#step-1-clone-the-repository","title":"Step 1: Clone the Repository","text":"<pre><code>git clone https://github.com/UzL-ITS/dasa-program-analysis.git\ncd dasa-program-analysis\n</code></pre>"},{"location":"installation/#step-2-build-the-docker-image","title":"Step 2: Build the Docker Image","text":"<p>The Docker image contains GraalVM and seafoam for extracting compiler graphs:</p> <pre><code>docker build -t dasa-graph-extractor .\n</code></pre> <p>This will download the GraalVM base image and install required tools (Ruby, graphviz, seafoam).</p> <p>Build Time</p> <p>The first build may take 5-10 minutes depending on your internet connection.</p>"},{"location":"installation/#step-3-set-up-python-environment","title":"Step 3: Set Up Python Environment","text":"<p>Create and activate a virtual environment:</p> <pre><code>python3 -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n</code></pre> <p>Install dependencies:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>The main dependencies are:</p> Package Purpose <code>torch</code> Gradient-based optimization <code>numpy</code> Numerical operations <code>sympy</code> Symbolic mathematics <code>tree-sitter</code> Java source parsing (for rewriting)"},{"location":"installation/#step-4-compile-helper-classes","title":"Step 4: Compile Helper Classes","text":"<p>Compile the SV-COMP Verifier helper class with your local Java:</p> <pre><code>cd svHelpers/evaluation\njavac org/sosy_lab/sv_benchmarks/Verifier.java\ncd ../..\n</code></pre>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<p>Run the smoke tests to verify everything works:</p> Two-Stage PipelineFull Pipeline (requires local GraalVM) <pre><code># Stage 1: Generate graph using Docker\ndocker run --rm \\\n  -v \"$(pwd)/SUTs/Smoketest1:/SUT\" \\\n  -v \"$(pwd)/svHelpers/evaluation:/svHelpers\" \\\n  -e TARGET=Main \\\n  dasa-graph-extractor\n\n# Stage 2: Compile Java locally and run optimization\njavac -cp svHelpers/evaluation SUTs/Smoketest1/Main.java -d SUTs/Smoketest1/\n\nsource venv/bin/activate\npython3 -c \"\nimport test\nresult = test.main(\n    'Main.main.json', None, None, True,\n    'SUTs/Smoketest1/', 'Main', 3\n)\nprint('SUCCESS!' if result == 3 else 'FAILED')\n\"\n</code></pre> <pre><code>./smoketest.sh\n</code></pre> <p>If you see <code>SUCCESS!</code> or <code>DASA_VERDICT: VIOLATION</code>, the installation is complete!</p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#docker-build-fails","title":"Docker Build Fails","text":"<p>If the Docker build fails, ensure you have enough disk space (at least 5GB) and a stable internet connection.</p>"},{"location":"installation/#java-class-version-error","title":"Java Class Version Error","text":"<p>If you see <code>UnsupportedClassVersionError</code>, your local Java version is older than the Docker Java version. Recompile the Java files locally:</p> <pre><code>javac -cp svHelpers/evaluation SUTs/YourProgram/Main.java -d SUTs/YourProgram/\n</code></pre>"},{"location":"installation/#python-import-errors","title":"Python Import Errors","text":"<p>Ensure you've activated the virtual environment and installed all dependencies:</p> <pre><code>source venv/bin/activate\npip install -r requirements.txt\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start - Run your first analysis</li> <li>Usage Examples - Learn common use cases</li> </ul>"},{"location":"nodes/","title":"Node Types","text":"<p>DASA models GraalVM compiler nodes as differentiable Python classes. This page documents the available node types.</p>"},{"location":"nodes/#control-flow-nodes","title":"Control Flow Nodes","text":""},{"location":"nodes/#ifnode","title":"IfNode","text":"<p>Represents conditional branching. Uses sigmoid for differentiable path selection.</p> <pre><code>class IfNode(BaseNode):\n    # Inputs: condition (boolean/numeric)\n    # Outputs to: trueSuccessor, falseSuccessor\n</code></pre> <p>Behavior: Distributes <code>controlFlowMultiplicative</code> to both branches based on sigmoid of condition.</p>"},{"location":"nodes/#mergenode","title":"MergeNode","text":"<p>Combines multiple control flow paths.</p> <pre><code>class MergeNode(BaseNode):\n    # Takes minimum controlFlowMultiplicative from incoming paths\n</code></pre>"},{"location":"nodes/#beginnode-endnode","title":"BeginNode / EndNode","text":"<p>Mark the start and end of basic blocks.</p>"},{"location":"nodes/#startnode","title":"StartNode","text":"<p>Entry point of a method.</p>"},{"location":"nodes/#returnnode","title":"ReturnNode","text":"<p>Method return point. Propagates values to callers.</p>"},{"location":"nodes/#value-nodes","title":"Value Nodes","text":""},{"location":"nodes/#constantnode","title":"ConstantNode","text":"<p>Holds literal values (integers, floats, strings).</p> <pre><code>class ConstantNode(BaseNode):\n    def exec(self):\n        # Extract value from node['props']['stamp']\n        self.output = parsed_value\n</code></pre>"},{"location":"nodes/#valuephinode","title":"ValuePhiNode","text":"<p>Selects between values based on incoming control flow (SSA phi function).</p> <pre><code>class ValuePhiNode(BaseNode):\n    # Selects input value from the path with highest flow\n</code></pre>"},{"location":"nodes/#parameternode","title":"ParameterNode","text":"<p>Method parameter. Receives values from caller.</p>"},{"location":"nodes/#pinode","title":"PiNode","text":"<p>Type narrowing node (e.g., after instanceof check).</p>"},{"location":"nodes/#arithmetic-nodes-nodescalc","title":"Arithmetic Nodes (nodes/calc/)","text":""},{"location":"nodes/#basic-operations","title":"Basic Operations","text":"Node Operation Example <code>AddNode</code> Addition <code>a + b</code> <code>SubNode</code> Subtraction <code>a - b</code> <code>MulNode</code> Multiplication <code>a * b</code> <code>DivNode</code> Division <code>a / b</code> <code>ModNode</code> Modulo <code>a % b</code> <code>NegateNode</code> Negation <code>-a</code>"},{"location":"nodes/#bitwise-operations","title":"Bitwise Operations","text":"Node Operation <code>LeftShiftNode</code> <code>a &lt;&lt; b</code>"},{"location":"nodes/#comparison-nodes","title":"Comparison Nodes","text":"Node Operation Returns <code>IntegerLessThanNode</code> <code>a &lt; b</code> Soft boolean (0.0-1.0) <code>IntegerEqualsNode</code> <code>a == b</code> Soft boolean <code>IntegerBelowNode</code> Unsigned <code>a &lt; b</code> Soft boolean <code>FloatLessThanNode</code> <code>a &lt; b</code> (float) Soft boolean <code>FloatEqualsNode</code> <code>a == b</code> (float) Soft boolean <code>FloatBelowNode</code> <code>a &lt; b</code> (unsigned float) Soft boolean <code>ObjectEqualsNode</code> Object equality Soft boolean <code>IsNullNode</code> <code>a == null</code> Soft boolean"},{"location":"nodes/#mathematical-functions","title":"Mathematical Functions","text":"Node Function <code>SinNode</code> <code>sin(x)</code> <code>CosNode</code> <code>cos(x)</code> <code>TanNode</code> <code>tan(x)</code> <code>AsinNode</code> <code>asin(x)</code> <code>AcosNode</code> <code>acos(x)</code> <code>AtanNode</code> <code>atan(x)</code> <code>Atan2Node</code> <code>atan2(y, x)</code> <code>ExpNode</code> <code>e^x</code> <code>LogNode</code> <code>ln(x)</code> <code>Log10Node</code> <code>log10(x)</code> <code>SqrtNode</code> <code>sqrt(x)</code> <code>PowNode</code> <code>x^y</code>"},{"location":"nodes/#conditional-node","title":"Conditional Node","text":"<pre><code>class ConditionalNode(BaseNode):\n    # condition ? trueValue : falseValue\n    # Uses soft selection based on condition\n</code></pre>"},{"location":"nodes/#java-nodes-nodesjava","title":"Java Nodes (nodes/java/)","text":""},{"location":"nodes/#loadfieldnode","title":"LoadFieldNode","text":"<p>Loads a field from an object.</p>"},{"location":"nodes/#loadindexednode","title":"LoadIndexedNode","text":"<p>Array element access: <code>array[index]</code></p>"},{"location":"nodes/#arraylengthnode","title":"ArrayLengthNode","text":"<p>Returns array length: <code>array.length</code></p>"},{"location":"nodes/#arrayequalsnode","title":"ArrayEqualsNode","text":"<p>Compares two arrays for equality.</p>"},{"location":"nodes/#charatnode","title":"CharAtNode","text":"<p>String character access: <code>str.charAt(index)</code></p>"},{"location":"nodes/#indexofnode","title":"IndexOfNode","text":"<p>String search: <code>str.indexOf(substring)</code></p>"},{"location":"nodes/#type-nodes-nodestypes","title":"Type Nodes (nodes/types/)","text":""},{"location":"nodes/#string","title":"String","text":"<p>Differentiable string representation using Gumbel-Softmax.</p> <pre><code>class String:\n    def __init__(self, length=10):\n        # Each character is a probability distribution over vocabulary\n        self.char_logits = [torch.randn(vocab_size) for _ in range(length)]\n\n    def to_string(self):\n        # Sample characters using current temperature\n        return sampled_string\n</code></pre>"},{"location":"nodes/#array","title":"Array","text":"<p>Represents Java arrays with differentiable access.</p>"},{"location":"nodes/#basetype","title":"BaseType","text":"<p>Base class for complex types.</p>"},{"location":"nodes/#virtual-nodes-nodesvirtual","title":"Virtual Nodes (nodes/virtual/)","text":""},{"location":"nodes/#virtualinstancenode","title":"VirtualInstanceNode","text":"<p>Represents an object that may be stack-allocated.</p>"},{"location":"nodes/#commitallocationnode","title":"CommitAllocationNode","text":"<p>Materializes virtual objects to heap.</p>"},{"location":"nodes/#allocatedobjectnode","title":"AllocatedObjectNode","text":"<p>Reference to an allocated object.</p>"},{"location":"nodes/#invocation-nodes","title":"Invocation Nodes","text":""},{"location":"nodes/#invokenode","title":"InvokeNode","text":"<p>Method invocation. May inline the called method's graph.</p> <pre><code>class InvokeNode(BaseNode):\n    def __init__(self, node):\n        # Check if method should be inlined\n        # Special handling for Verifier.nondet* methods\n</code></pre> <p>Special Methods:</p> <ul> <li><code>Verifier.nondet*()</code>: Treated as input sources</li> <li><code>FdLibm.*</code>: Replaced with math functions</li> <li><code>String.charAt</code>: Uses CharAtNode</li> <li><code>String.indexOf</code>: Uses IndexOfNode</li> </ul>"},{"location":"nodes/#exception-nodes","title":"Exception Nodes","text":""},{"location":"nodes/#throwbytecodeexceptionnode","title":"ThrowBytecodeExceptionNode","text":"<p>Target node for exceptions:</p> <ul> <li>Array index out of bounds</li> <li>Null pointer</li> <li>Class cast</li> <li>Division by zero</li> </ul> <p>These are typically end nodes that DASA tries to reach.</p>"},{"location":"nodes/#utility-nodes","title":"Utility Nodes","text":""},{"location":"nodes/#framestate","title":"FrameState","text":"<p>Debugging information (not executed).</p>"},{"location":"nodes/#fullinfopointnode","title":"FullInfoPointNode","text":"<p>Source location information.</p>"},{"location":"nodes/#fallbacknode","title":"FallbackNode","text":"<p>Used for unrecognized node types. Passes through values without modification.</p>"},{"location":"nodes/#custom-nodes-nodescustom","title":"Custom Nodes (nodes/custom/)","text":""},{"location":"nodes/#sigmoid","title":"Sigmoid","text":"<p>Annealing sigmoid function for differentiable control flow.</p> <pre><code>class Sigmoid:\n    annealing_constant = 0.001  # Starts soft, becomes sharp\n\n    @classmethod\n    def set_annealing_constant(cls, value):\n        cls.annealing_constant = value\n</code></pre>"},{"location":"nodes/#mathfunctions","title":"MathFunctions","text":"<p>Additional mathematical operations.</p>"},{"location":"nodes/#adding-new-node-types","title":"Adding New Node Types","text":"<p>To add support for a new GraalVM node type:</p> <ol> <li>Create a new class in the appropriate directory:</li> </ol> <pre><code># nodes/calc/MyNewNode.py\nfrom nodes.BaseNode import BaseNode\n\nclass MyNewNode(BaseNode):\n    def exec(self):\n        x = self.inputs['x']\n        y = self.inputs['y']\n        self.output = x + y  # Your computation\n</code></pre> <ol> <li>Register it in <code>GraalWrapper/GraphBuilder.py</code>:</li> </ol> <pre><code>elif node_class == 'jdk.graal.compiler.nodes.calc.MyNewNode':\n    new_graph[node['id']] = nodes.calc.MyNewNode(node)\n</code></pre> <ol> <li>Export it in <code>nodes/calc/__init__.py</code>:</li> </ol> <pre><code>from .MyNewNode import MyNewNode\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>This guide will walk you through analyzing your first Java program with DASA.</p>"},{"location":"quickstart/#create-a-test-program","title":"Create a Test Program","text":"<p>Create a directory for your program:</p> <pre><code>mkdir -p SUTs/MyFirstTest\n</code></pre> <p>Create <code>SUTs/MyFirstTest/Main.java</code>:</p> <pre><code>import org.sosy_lab.sv_benchmarks.Verifier;\n\nclass Main {\n    public static void main(String[] args) {\n        int x = Verifier.nondetInt();\n        int y = Verifier.nondetInt();\n\n        if (x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; x + y == 42) {\n            assert false : \"Found the answer!\";\n        }\n\n        System.out.println(\"No solution found\");\n    }\n}\n</code></pre> <p>This program has a hidden assertion that triggers when <code>x + y == 42</code> with both positive.</p>"},{"location":"quickstart/#stage-1-extract-the-computation-graph","title":"Stage 1: Extract the Computation Graph","text":"<p>Use Docker to compile with GraalVM and extract the compiler graph:</p> <pre><code>docker run --rm \\\n  -v \"$(pwd)/SUTs/MyFirstTest:/SUT\" \\\n  -v \"$(pwd)/svHelpers/evaluation:/svHelpers\" \\\n  -e TARGET=Main \\\n  dasa-graph-extractor\n</code></pre> <p>You should see GraalVM native-image output, ending with:</p> <pre><code>Graph generation complete!\n-rw-r--r-- 1 root root XXXXX /SUT/Main.main.json\n</code></pre>"},{"location":"quickstart/#stage-2-run-the-optimization","title":"Stage 2: Run the Optimization","text":"<p>First, compile the Java file locally (for test execution):</p> <pre><code>javac -cp svHelpers/evaluation SUTs/MyFirstTest/Main.java -d SUTs/MyFirstTest/\n</code></pre> <p>Now run the DASA optimization:</p> <pre><code>source venv/bin/activate\npython3 -c \"\nimport test\n\nresult = test.main(\n    target_file='Main.main.json',\n    start_nodes=None,\n    end_nodes=None,\n    auto_detect_start_end=True,\n    test_dir='SUTs/MyFirstTest/',\n    test_class='Main',\n    num_iterations=10,\n    verbose=False\n)\n\nif result == test.STATE_CORRECT:\n    print('SUCCESS: Found inputs that trigger the assertion!')\nelse:\n    print('No violation found')\n\"\n</code></pre>"},{"location":"quickstart/#understanding-the-output","title":"Understanding the Output","text":"<p>DASA will output something like:</p> <pre><code>Start nodes: [33, 45]\nEnd nodes: [72]\nTarget 72 Try 0: Inputs=[33, 45] Values=[21, 21] Loss=-0.999...\n----------- Input of the test execution ------------\nb'INPUT_000 21\\nINPUT_001 21'\n----------- Output of the test execution -----------\nException in thread \"main\" java.lang.AssertionError: Found the answer!\n</code></pre> <p>This shows:</p> <ul> <li>Start nodes: The <code>Verifier.nondetInt()</code> calls (input sources)</li> <li>End nodes: The assertion/exception target</li> <li>Values: The discovered inputs (<code>x=21, y=21</code>, and <code>21+21=42</code>)</li> <li>AssertionError: Confirms the violation was triggered</li> </ul>"},{"location":"quickstart/#using-the-verifier-api","title":"Using the Verifier API","text":"<p>DASA uses the SV-COMP Verifier class for nondeterministic inputs:</p> Method Type Description <code>Verifier.nondetInt()</code> <code>int</code> Nondeterministic 32-bit integer <code>Verifier.nondetLong()</code> <code>long</code> Nondeterministic 64-bit integer <code>Verifier.nondetFloat()</code> <code>float</code> Nondeterministic float <code>Verifier.nondetDouble()</code> <code>double</code> Nondeterministic double <code>Verifier.nondetBoolean()</code> <code>boolean</code> Nondeterministic boolean <code>Verifier.nondetChar()</code> <code>char</code> Nondeterministic character <code>Verifier.nondetString()</code> <code>String</code> Nondeterministic string <code>Verifier.nondetByte()</code> <code>byte</code> Nondeterministic byte <code>Verifier.nondetShort()</code> <code>short</code> Nondeterministic short"},{"location":"quickstart/#what-dasa-finds","title":"What DASA Finds","text":"<p>DASA automatically detects and targets:</p> <ul> <li><code>assert false</code> statements</li> <li><code>throw new AssertionError()</code></li> <li><code>BytecodeExceptionNode</code> (array bounds, null pointer, etc.)</li> </ul>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Usage Examples - More complex examples</li> <li>Architecture - How DASA works internally</li> <li>Configuration - Tuning optimization parameters</li> </ul>"},{"location":"usage/","title":"Usage Examples","text":"<p>This page provides detailed examples for common DASA use cases.</p>"},{"location":"usage/#example-1-finding-integer-bounds","title":"Example 1: Finding Integer Bounds","text":"<p>Find values that satisfy complex integer constraints:</p> <pre><code>import org.sosy_lab.sv_benchmarks.Verifier;\n\nclass BoundsCheck {\n    public static void main(String[] args) {\n        int a = Verifier.nondetInt();\n        int b = Verifier.nondetInt();\n        int c = Verifier.nondetInt();\n\n        if (a &gt; 10 &amp;&amp; a &lt; 20) {\n            if (b &gt; a &amp;&amp; b &lt; 30) {\n                if (c == a + b) {\n                    assert false : \"Found valid combination!\";\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>DASA will find values like <code>a=15, b=20, c=35</code> that satisfy all conditions.</p>"},{"location":"usage/#example-2-string-matching","title":"Example 2: String Matching","text":"<p>DASA supports differentiable string generation:</p> <pre><code>import org.sosy_lab.sv_benchmarks.Verifier;\n\nclass StringMatch {\n    public static void main(String[] args) {\n        String input = Verifier.nondetString();\n\n        if (input.indexOf(\"secret\") &gt;= 0) {\n            assert false : \"Found secret!\";\n        }\n    }\n}\n</code></pre> <p>DASA uses Gumbel-Softmax sampling to generate strings that contain the target substring.</p>"},{"location":"usage/#example-3-array-operations","title":"Example 3: Array Operations","text":"<pre><code>import org.sosy_lab.sv_benchmarks.Verifier;\n\nclass ArrayBounds {\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5};\n        int idx = Verifier.nondetInt();\n\n        // This will find idx &lt; 0 or idx &gt;= 5\n        int value = arr[idx];\n        System.out.println(value);\n    }\n}\n</code></pre> <p>DASA targets <code>BytecodeExceptionNode</code> for array bounds violations.</p>"},{"location":"usage/#example-4-multiple-input-types","title":"Example 4: Multiple Input Types","text":"<pre><code>import org.sosy_lab.sv_benchmarks.Verifier;\n\nclass MultiType {\n    public static void main(String[] args) {\n        int i = Verifier.nondetInt();\n        double d = Verifier.nondetDouble();\n        boolean b = Verifier.nondetBoolean();\n\n        if (b &amp;&amp; i &gt; 100 &amp;&amp; d &gt; 3.14 &amp;&amp; d &lt; 3.15) {\n            assert false : \"Found precise values!\";\n        }\n    }\n}\n</code></pre>"},{"location":"usage/#running-multiple-iterations","title":"Running Multiple Iterations","text":"<p>For complex programs, run multiple optimization iterations:</p> <pre><code>import test\n\nresult = test.main(\n    target_file='Main.main.json',\n    start_nodes=None,\n    end_nodes=None,\n    auto_detect_start_end=True,\n    test_dir='SUTs/MyProgram/',\n    test_class='Main',\n    num_iterations=100,  # More attempts\n    verbose=True         # Show progress\n)\n</code></pre>"},{"location":"usage/#batch-analysis-script","title":"Batch Analysis Script","text":"<p>Create a script to analyze multiple programs:</p> <pre><code>#!/usr/bin/env python3\nimport os\nimport test\n\nprograms = ['Program1', 'Program2', 'Program3']\n\nfor prog in programs:\n    test_dir = f'SUTs/{prog}/'\n    json_file = 'Main.main.json'\n\n    if not os.path.exists(os.path.join(test_dir, json_file)):\n        print(f\"Skipping {prog}: no graph file\")\n        continue\n\n    result = test.main(\n        target_file=json_file,\n        start_nodes=None,\n        end_nodes=None,\n        auto_detect_start_end=True,\n        test_dir=test_dir,\n        test_class='Main',\n        num_iterations=10\n    )\n\n    status = \"VIOLATION\" if result == test.STATE_CORRECT else \"UNKNOWN\"\n    print(f\"{prog}: {status}\")\n</code></pre>"},{"location":"usage/#using-custom-startend-nodes","title":"Using Custom Start/End Nodes","text":"<p>For fine-grained control, specify nodes manually:</p> <pre><code>from GraalWrapper.InputNodeTypes import input_node_tuple, TYPE_CONV_INT\n\n# Specify exact input nodes and their types\nstart_nodes = [\n    input_node_tuple(33, TYPE_CONV_INT),\n    input_node_tuple(45, TYPE_CONV_INT)\n]\n\n# Target specific assertion node\nend_nodes = [72]\n\nresult = test.main(\n    target_file='Main.main.json',\n    start_nodes=start_nodes,\n    end_nodes=end_nodes,\n    auto_detect_start_end=False,  # Use manual nodes\n    test_dir='SUTs/MyProgram/',\n    test_class='Main',\n    num_iterations=10\n)\n</code></pre>"},{"location":"usage/#handling-different-input-types","title":"Handling Different Input Types","text":"<pre><code>from GraalWrapper.InputNodeTypes import (\n    input_node_tuple,\n    string_input_node_tuple,\n    TYPE_CONV_INT,\n    TYPE_CONV_FLOAT,\n    TYPE_CONV_BOOL,\n    TYPE_CONV_CHAR,\n    TYPE_CONV_STRING\n)\n\nstart_nodes = [\n    input_node_tuple(33, TYPE_CONV_INT),\n    input_node_tuple(45, TYPE_CONV_FLOAT),\n    input_node_tuple(52, TYPE_CONV_BOOL),\n    string_input_node_tuple(60, TYPE_CONV_STRING, string_length=20)\n]\n</code></pre>"},{"location":"usage/#interpreting-results","title":"Interpreting Results","text":"<p>The <code>test.main()</code> function returns a state code:</p> Code Constant Meaning 0 <code>STATE_DEFAULT</code> Default state 1 <code>STATE_NO_START_NODES_FOUND</code> No input sources found 2 <code>STATE_NO_END_NODES_FOUND</code> No target nodes found 3 <code>STATE_CORRECT</code> Found violation (success!) 4 <code>STATE_INCORRECT</code> No violation found 5 <code>STATE_ERROR</code> Error during analysis"},{"location":"usage/#verbose-output","title":"Verbose Output","text":"<p>Enable verbose mode to see optimization progress:</p> <pre><code>result = test.main(\n    target_file='Main.main.json',\n    start_nodes=None,\n    end_nodes=None,\n    auto_detect_start_end=True,\n    test_dir='SUTs/MyProgram/',\n    test_class='Main',\n    num_iterations=5,\n    verbose=True  # Shows iteration-by-iteration loss\n)\n</code></pre> <p>Output: <pre><code>Iteration 0: Values=['17.00'] Loss=-0.501...\nIteration 1: Values=['17.10'] Loss=-0.502...\n...\nIteration 1324: Values=['45.65'] Loss=-0.999...\n</code></pre></p> <p>The loss approaching <code>-1.0</code> indicates high confidence in reaching the target.</p>"}]}